<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export4.dtd">
<en-export export-date="20220122T102859Z" application="Evernote" version="10.24.3">
  <note>
    <title>Count Number of consecutive 1&apos;s</title>
    <created>20210715T115857Z</created>
    <updated>20210715T124933Z</updated>
    <note-attributes>
      <author>Akshay Yadav</author>
    </note-attributes>
    <content>
      <![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd"><en-note><div>problem: Given a array, count maximum number of consecutive 1's that can be achieved by flipping maximum k 0's.</div><div>solution Approach:</div><div>This questions belongs to variable size window. where we have to find longest subarray count (window size) , which can found by flipping  max k zero's. </div><ol><ol><li><div>base case , if number of zero in the given array is less then given k i.e number of zero that can be flipped, then return array size as response, because all the zero's can be flipped. </div></li><li><div>then apply sliding window. </div></li><li><div>condition : number of zero equals to given k value</div></li><li><div>If number of zero grater then k, then sliding window from start point.</div></li></ol></ol><div>               5. If number of zero = k, then find maxConsecutiveCount. </div><div style="--en-codeblock:true;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>public int longestOnes(int[] nums, int k) {</div><div>      int i = 0, j =0;</div><div>      int numZeroes = 0;</div><div>      int maxConsecutiveOnes = 0;</div><div>      for(int l=0; l&lt; nums.length; l++){</div><div>          if(nums[l] == 0){</div><div>              numZeroes++;</div><div>          }</div><div>      }  </div><div>      if(k &gt; numZeroes){</div><div>          return nums.length;</div><div>      }  </div><div>      numZeroes = 0;</div><div>      while(j &lt; nums.length){</div><div>         </div><div>         if(nums[j] == 0){</div><div>            numZeroes++;</div><div>         }</div><div>           </div><div>         if(numZeroes == k){</div><div>              maxConsecutiveOnes = Math.max(maxConsecutiveOnes, j- i + 1);</div><div>         }</div><div>         else if(numZeroes &gt; k){ </div><div>            if(nums[i] == 0){</div><div>                numZeroes--;</div><div>            }</div><div>            i++;</div><div>         }</div><div>         j++;</div><div>      }</div><div>      return maxConsecutiveOnes;</div><div>    }</div></div><div><br /></div></en-note>      ]]>
    </content>
  </note>
  <note>
    <title>Maximum sum/product subarray</title>
    <created>20210715T133657Z</created>
    <updated>20210716T025800Z</updated>
    <note-attributes>
      <author>Akshay Yadav</author>
    </note-attributes>
    <content>
      <![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd"><en-note><div>problem:  Given a Array, find the subarray with largest sum/prduct</div><div>Note: This problem is different from <b> maximum sum subarray of size k </b>. Here we need to find all the subarray of size k and find that subarray whose elements sum is maximum.</div><div>Here we just need to find subarray with maximum sum. </div><div><br /></div><div style="--en-codeblock:true;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>// subarray with largest sum</div><div>class Solution { </div><div>    public int maxSumSubArray(int[] nums) { </div><div>        if(nums.length == 0)  </div><div>            return 0; </div><div>        int s = 0;  </div><div>        int max = Integer.MIN_VALUE; </div><div>        for(int i=0; i &lt; nums.length; i++){ </div><div>            for(int j=i; j &lt; nums.length ; j++){ </div><div>              s += nums[j]; </div><div>              max = Math.max(max,s); </div><div>            } </div><div>            s = 0; </div><div>        } </div><div>        return max; </div><div>    } </div><div>Time complexity : O(n^2)</div><div><br /></div></div><div><br /></div><ol><li><h4 style="text-align:start;"><span style="color:rgba(0, 0, 0, 0.85);">Dynamic Programming, Kadane's Algorithm</span></h4></li></ol><div><span style="color:rgba(0, 0, 0, 0.85);">    </span></div><div><span style="color:rgb(39, 50, 57);">The simple idea of Kadane’s algorithm is to look for all positive contiguous segments of the array (max_ending_here is used for this). And keep track of maximum sum contiguous segment among all positive segments (max_so_far is used for this). Each time we get a positive-sum compare it with max_so_far and update max_so_far if it is greater than max_so_far </span></div><div><span style="color:rgba(0, 0, 0, 0.85);"><span style="--en-markholder:true;"><br /></span></span></div><div style="--en-codeblock:true;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>public int maxSubArray(int[] nums) { </div><div>        if(nums.length == 0)  </div><div>            return 0; </div><div>       int curr_max_sum = Integer.MIN_VALUE, max_ending_here = 0; </div><div>        for(int i = 0; i &lt; nums.length; i++){ </div><div>            max_ending_here  += nums[i]; </div><div>            if(curr_max_sum &lt; max_ending_here){ </div><div>                curr_max_sum = max_ending_here; </div><div>            } </div><div>            if(max_ending_here &lt; 0){ </div><div>                max_ending_here = 0; </div><div>            } </div><div>        } </div><div>         </div><div>        return curr_max_sum; </div><div>    }</div><div><br /></div><div><br /></div><div>// If we have to print subarray with maximum sum, keep track of starting and ending index of subarray.</div><div>   </div><div>  public int[] printMaxSumSubArray(int[] arr){</div><div>   if(arr.length == 0)</div><div>      return new int[1];</div><div>    int currMax = Integer.MIN_VALUE, maxEndHere = 0, start = 0, end = 0, big = 0;</div><div>    for(int i=0; i &lt; arr.length; i++){</div><div>       maxEndHere += arr[i];</div><div>       if(maxEndHere &lt; 0){</div><div>           maxEndHere = 0;</div><div>           big = i+1; </div><div>       }else if(maxEndHere &gt; currMax){</div><div>         currMax = maxEndHere;</div><div>          start = big;</div><div>           end = i;</div><div>       }</div><div>    }</div><div>   int[] res = new int[end-start];</div><div>   int l = 0;</div><div>   for(int i= start; i &lt; end; i++){</div><div>      arr[i] = res[l++];</div><div>    }</div><div>    return res;</div><div>  }</div><div><br /></div><div><br /></div></div><div>Time complexity : O(n<sup>2 </sup>)</div><div><br /></div><ul><li><div><b>max product subarray </b></div></li></ul><div><br /></div><div style="--en-codeblock:true;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>public int maxProduct(int[] nums) { </div><div>        if(nums.length == 0)  </div><div>            return 0; </div><div>        int P = 1;  </div><div>        int max = Integer.MIN_VALUE; </div><div>        for(int i=0; i &lt; nums.length; i++){ </div><div>            for(int j=i; j &lt; nums.length ; j++){ </div><div>              P *= nums[j]; </div><div>              max = Math.max(max,P); </div><div>            } </div><div>            P = 1; </div><div>        } </div><div>        return max; </div><div>    } </div><div>}</div></div><div><br /></div><div>Time Complexity: O(n<sup>2</sup>)</div><div><br /></div><div> Max product can be obtained by product of two positive number and two negative number. </div><div> so we will maintain maxval represents max product till current index and minval will represent  product of negative integer till current index</div><div> and maxProduct will hold overall max product.</div><div><br /></div><div style="--en-codeblock:true;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>public int maxProduct(int[] nums) {</div><div>        if(nums.length == 0) </div><div>            return 0;</div><div>        int minval = nums[0], maxval = nums[0], maxProduct = nums[0];</div><div>        </div><div>        </div><div>        for(int i=1; i &lt; nums.length; i++){</div><div>            </div><div>        // if current index is negative then max will become min and min will become </div><div>        max after product, so swap  max and min values</div><div>            if(nums[i] &lt; 0){</div><div>                int temp = maxval;</div><div>                maxval = minval;</div><div>                minval = temp;</div><div>            }</div><div>            </div><div>            maxval = Math.max(nums[i],nums[i]*maxval);</div><div>            minval = Math.min(nums[i],nums[i]*minval);</div><div>            </div><div>            maxProduct = Math.max(maxProduct, maxval);</div><div>        }</div><div>        return maxProduct;</div><div>    }</div></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div></en-note>      ]]>
    </content>
  </note>
  <note>
    <title>Merge Interval</title>
    <created>20210722T161717Z</created>
    <updated>20211007T065721Z</updated>
    <note-attributes>
      <author>Akshay Yadav</author>
    </note-attributes>
    <content>
      <![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd"><en-note><div><span style="color:rgb(182, 41, 212);">use cases</span> :  meeting room , train arrival departure problems.</div><div>conditions : </div><ol><li><div>If intervals overlaps, means  end of current interval is grater than start of next interval. Means intervals are overlaping. exam : 3 is grater then 2 </div></li></ol><div>           1 2 3 4 5 6</div><div>           --<span style="--en-highlight:red;background-color: #fec1d0;">---</span></div><div>              <span style="--en-highlight:yellow;background-color: #ffef9e;">---</span>--------</div><div>             color overlapping region. </div><div>             In this case, end of current interval should be replaced with end of next interval</div><div>             Exam : [[1,3], [2,6]] : result should be [1,6] : intervals are overlapped.</div><div>    2.  If one interval can consume another interval completely, then no merging is required</div><div>          Exam:  [[1,6],[2,4]] = [1,6]</div><div>    3. If two intervals are not overlapping means end of current interval is less than start of next interval. Then new interval is found and <b>No merging </b></div><div><b>         </b>will be performed. </div><div>         Exam:   [[1,4], [6,8]] =  [[1,4], [6,8]]</div><div>1 2 3 4 5 6 7 8</div><div><span style="--en-highlight:red;background-color: #fec1d0;"> -------</span></div><div>                  <span style="--en-highlight:yellow;background-color: #ffef9e;">-----</span></div><div>no overlapping </div><div><br /></div><div>PS: <a href="https://leetcode.com/problems/merge-intervals/" rev="en_rl_none">https://leetcode.com/problems/merge-intervals/</a></div><div style="--en-codeblock:true;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>class Solution { </div><div>    static class Pair implements Comparable&lt;Pair&gt;{ </div><div>        int start; </div><div>        int end; </div><div>         </div><div>        public Pair(int start , int end){ </div><div>            this.start = start; </div><div>            this.end = end; </div><div>        } </div><div>        @Override </div><div>        public int compareTo(Pair other){ </div><div>            if(this.start != other.start){ </div><div>                return this.start - other.start; </div><div>            }else{ </div><div>                return this.end - other.end; </div><div>            } </div><div>        } </div><div>    } </div><div>     </div><div>    public int[][] merge(int[][] intervals) { </div><div>        Pair[] pairs = new Pair[intervals.length]; </div><div>        for(int i=0; i &lt; intervals.length; i++){ </div><div>            pairs[i] = new Pair(intervals[i][0], intervals[i][1]); </div><div>        } </div><div>        Arrays.sort(pairs); </div><div>        Stack&lt;Pair&gt; sp = new Stack&lt;&gt;(); </div><div>        sp.push(pairs[0]); </div><div>        for(int i=1; i &lt; pairs.length; i++){ </div><div>            Pair prev = sp.peek(); </div><div>            Pair curr = pairs[i]; </div><div>             </div><div>            if(prev.end &gt; curr.start &amp;&amp; prev.end &gt; curr.end){ </div><div>               continue; </div><div>            }else if(prev.end &gt;= curr.start &amp;&amp; (prev.end &lt; curr.end)){ </div><div>                sp.pop(); </div><div>                prev.end = curr.end; </div><div>                sp.push(prev); </div><div>            }else if(prev.end &lt; curr.start){ </div><div>                sp.push(curr); </div><div>            } </div><div>        } </div><div>         </div><div>        Stack&lt;Pair&gt; fsp = new Stack&lt;&gt;(); </div><div>         </div><div>        while(!sp.isEmpty()){ </div><div>           fsp.push(sp.pop()); </div><div>        } </div><div>        int[][] res = new int[fsp.size()][2]; </div><div>         </div><div>        int i = 0; </div><div>        while(!fsp.isEmpty()){ </div><div>            Pair p = fsp.pop(); </div><div>            res[i][0] = p.start; </div><div>            res[i][1] = p.end; </div><div>            i++; </div><div>        } </div><div>       return res;   </div><div>    } </div><div>}</div></div><div><br /></div><div><br /></div><ol><li><div><span style="color:rgb(87, 36, 194);">Meeting room 1: </span></div></li></ol><div><span style="color:rgb(87, 36, 194);">    </span><a href="https://leetcode.com/problems/meeting-rooms/" rev="en_rl_none"><span style="color:rgb(87, 36, 194);">https://leetcode.com/problems/meeting-rooms/</span></a></div><div><span style="color:rgb(87, 36, 194);">     PS : </span><span style="color:rgb(38, 50, 56);">Given an array of meeting time </span><span style="color:rgb(84, 110, 122);">intervals</span><span style="color:rgb(38, 50, 56);"> where </span><span style="color:rgb(84, 110, 122);">intervals[i] = [start</span><sub><span style="color:rgb(84, 110, 122);">i</span></sub><span style="color:rgb(84, 110, 122);">, end</span><sub><span style="color:rgb(84, 110, 122);">i</span></sub><span style="color:rgb(84, 110, 122);">]</span><span style="color:rgb(38, 50, 56);">, determine if a person could attend all meetings.</span></div><div><span style="color:rgb(38, 50, 56);">     solution</span><sup><span style="color:rgb(38, 50, 56);"> </span></sup><span style="color:rgb(38, 50, 56);"> : A person can attend a meet if meetings are not overlapping. </span></div><div><span style="color:rgb(38, 50, 56);">    If one meeting time can be consumed by other meeting completely,  means person can attend that meeting too. </span></div><div><span style="color:rgb(38, 50, 56);">            </span></div><div style="--en-codeblock:true;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>class Solution { </div><div>    public boolean canAttendMeetings(int[][] intervals) { </div><div>        if(intervals.length == 0){ </div><div>            return true; </div><div>        } </div><div>       Arrays.sort(intervals, (a, b) -&gt; a[0]- b[0]); </div><div>        int fs = intervals[0][0];// 7 </div><div>        int fe = intervals[0][1];// 10 </div><div>         </div><div>        for(int i = 1; i &lt; intervals.length; i++){ </div><div>            int ns = intervals[i][0]; // 2 </div><div>            int ne = intervals[i][1]; // 4 </div><div>            if(fs &gt; ns &amp;&amp; fe &gt; ne){ </div><div>                return true; </div><div>            }else if(fe &gt; ns){ </div><div>                return false; </div><div>            } </div><div>            fs = ns; </div><div>            fe = ne; </div><div>        } </div><div>        return true; </div><div>    } </div><div>}</div></div><div><span style="color:rgb(87, 36, 194);">    </span></div><ol start="2"><li><div><span style="color:rgb(87, 36, 194);">Meeting room 2: </span></div></li></ol><div>           <a href="https://leetcode.com/problems/meeting-rooms-ii/" rev="en_rl_none">https://leetcode.com/problems/meeting-rooms-ii/</a></div><div><br /></div><div style="--en-codeblock:true;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>public int minMeetingRooms(Interval[] intervals) { </div><div>    if (intervals == null || intervals.length == 0) </div><div>        return 0; </div><div>         </div><div>    // Sort the intervals by start time </div><div>    Arrays.sort(intervals, new Comparator&lt;Interval&gt;() { </div><div>        public int compare(Interval a, Interval b) { return a.start - b.start; } </div><div>    }); </div><div>     </div><div>    // Use a min heap to track the minimum end time of merged intervals </div><div>    PriorityQueue&lt;Interval&gt; heap = new PriorityQueue&lt;Interval&gt;(intervals.length, new Comparator&lt;Interval&gt;() { </div><div>        public int compare(Interval a, Interval b) { return a.end - b.end; } </div><div>    }); </div><div>     </div><div>    // start with the first meeting, put it to a meeting room </div><div>    heap.offer(intervals[0]); </div><div>     </div><div>    for (int i = 1; i &lt; intervals.length; i++) { </div><div>        // get the meeting room that finishes earliest </div><div>        Interval interval = heap.poll(); </div><div>         </div><div>        if (intervals[i].start &gt;= interval.end) { </div><div>            // if the current meeting starts right after  </div><div>            // there's no need for a new room, merge the interval </div><div>            interval.end = intervals[i].end; </div><div>        } else { </div><div>            // otherwise, this meeting needs a new room </div><div>            heap.offer(intervals[i]); </div><div>        } </div><div>         </div><div>        // don't forget to put the meeting room back </div><div>        heap.offer(interval); </div><div>    } </div><div>     </div><div>    return heap.size(); </div><div>}</div></div><div><span style="color:rgb(87, 36, 194);"><span style="--en-markholder:true;"><br /></span></span></div></en-note>      ]]>
    </content>
  </note>
  <note>
    <title>Sub array with matching degree</title>
    <created>20210723T131243Z</created>
    <updated>20210723T132135Z</updated>
    <note-attributes>
      <author>Akshay Yadav</author>
    </note-attributes>
    <content>
      <![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd"><en-note><div><b>problem</b> : given array with repeated characters, degree of array is maximum no of any character repetition.  find the smallest subarray with same indegree. </div><div><a href="https://leetcode.com/problems/degree-of-an-array/">https://leetcode.com/problems/degree-of-an-array/</a></div><div><br /></div><div>solution: </div><div>take two map to keep track of left index of an element, right index of an element</div><div>and one map to keep character with repetition count. </div><div>then find max values from count map. that will be degree of map.</div><div>now find the char which has max degree.</div><div>then find left and right index with given map.</div><div>return min length of subarray with matching degree</div><div><br /></div><div style="--en-codeblock:true;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>class Solution {</div><div>    public int findShortestSubArray(int[] nums) {</div><div>        Map&lt;Integer,Integer&gt; left = new HashMap&lt;&gt;(),</div><div>        right = new HashMap&lt;&gt;(), count = new HashMap&lt;&gt;();</div><div>        </div><div>        for(int i=0; i &lt; nums.length; i++){</div><div>            if(left.get(nums[i]) == null) left.put(nums[i], i);</div><div>            right.put(nums[i], i);</div><div>            count.put(nums[i], count.getOrDefault(nums[i], 0)+1);</div><div>        }</div><div>           </div><div>        int ans = nums.length;</div><div>        int degree = Collections.max(count.values());</div><div>        for(Integer x : count.keySet()){</div><div>             if(de == count.get(x)){</div><div>                 ans = Math.min(ans, right.get(x) - left.get(x)+1);</div><div>             }</div><div>        }</div><div>        return ans;</div><div>    }</div><div>}</div></div><div><br /></div><div><br /></div></en-note>      ]]>
    </content>
  </note>
</en-export>
