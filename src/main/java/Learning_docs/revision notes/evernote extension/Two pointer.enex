<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export4.dtd">
<en-export export-date="20220122T103237Z" application="Evernote" version="10.24.3">
  <note>
    <title>Three sum</title>
    <created>20210715T035854Z</created>
    <updated>20210715T051032Z</updated>
    <note-attributes>
      <author>Akshay Yadav</author>
    </note-attributes>
    <content>
      <![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd"><en-note><div>Problem: Given an array, find all the triplets whose sum equals to zero. </div><div>Thought:</div><div>Given array,</div><ul><li><div>As we want to use two pointer approach, so sort the array first  and then Iterate over the array</div></li><li><div>take each element from array, and apply two sum on rest of the array. </div></li><li><div> if two consecutive elements are same, then skip them to avoid duplicate triplets.</div></li><li><div>while finding two sum,  start should point to the next element of current index, for exam</div></li></ul><div>if we are processing element at index 1, then twoSum should start with index 2, and end index will be array end.  </div><ul><li><div> Once triplets found, increase start and end pointer, because we are not terminating loop on finding one triplet. </div></li><li><div>once found the triplet, if next element to  be processed (element at start and last processed i.e start-1) and element already processed are same, then skip them. </div></li></ul><div><br /></div><div style="--en-codeblock:true;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>class Solution {</div><div>    List&lt;List&lt;Integer&gt;&gt; response = new ArrayList&lt;&gt;();</div><div>   </div><div>    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] array) {</div><div>      if(array.length == 0)</div><div>          return response;</div><div>     Arrays.sort(array);</div><div>     for(int i=0; i &lt; array.length ; i++){</div><div>          if (i == 0 || array[i - 1] != array[i]) {</div><div>               twoSum(array,i);</div><div>            }</div><div>     }</div><div>        return response;</div><div>    }</div><div>    </div><div>    public void twoSum(int[] arr,int i){</div><div>        int start = i+1, end = arr.length-1;</div><div>        </div><div>        while(start &lt; end){</div><div>            int sum = arr[start] + arr[end]+ arr[i];</div><div>            if(sum == 0){</div><div>                response.add(Arrays.asList(arr[i],arr[start],arr[end]));</div><div>                start++;</div><div>                end--;</div><div>                while (start &lt; end &amp;&amp; arr[start] == arr[start - 1])</div><div>                    start++;</div><div>            }else if(sum &gt; 0){</div><div>                end--;</div><div>            }else{</div><div>                start++;</div><div>            }</div><div>        }</div><div>    }</div><div>}</div></div><div><br /></div></en-note>      ]]>
    </content>
  </note>
  <note>
    <title>Two sum</title>
    <created>20210706T000442Z</created>
    <updated>20210706T002732Z</updated>
    <note-attributes>
      <author>Akshay Yadav</author>
    </note-attributes>
    <content>
      <![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd"><en-note><div>   PS : Given an array [un sorted], find indices of two number such that sum of  number on those indices is equal to target given. </div><ol><li><div><span style="color:rgb(24, 168, 65);">Brute Force: </span></div></li></ol><div><br /></div><div style="--en-codeblock:true;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>public int[] twoSum(int[] nums, int target) {</div><div>       for(int i =0; i&lt; nums.length; i++){</div><div>           for(int j = i+1; j &lt; nums.length ; j++){</div><div>               if(nums[i] + nums[j] == target){</div><div>                   return new int[]{i,j};</div><div>               }</div><div>           }</div><div>       }</div><div>        return new int[2];</div><div>    }</div><div><br /></div><div><br /></div></div><div style="text-align:start;"><b>Complexity Analysis</b></div><div><br /></div><ul><li><div>Time complexity : O(n^2)<i> </i>. For each element, we try to find its complement by looping through the rest of array which takes O(n) time. Therefore, the time complexity is O(n^2).</div></li><li><div style="margin-bottom:16px;">Space complexity : O(1)<i>O</i>(1).</div></li></ul><div> </div><div>2.  <span style="color:rgb(24, 168, 65);">Dictionary or Map : </span></div><div style="padding-left:40px;"><span style="color:rgba(0, 0, 0, 0.65);">To improve our run time complexity, we need a more efficient way to check if the complement exists in the array. If the complement exists, we need to look up its index. What is the best way to maintain a mapping of each element in the array to its index? A hash table.</span></div><div style="--en-codeblock:true;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>public int[] twoSum(int[] nums, int target) {</div><div>    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</div><div>    for (int i = 0; i &lt; nums.length; i++) {</div><div>        int complement = target - nums[i];</div><div>        if (map.containsKey(complement)) {</div><div>            return new int[] { map.get(complement), i };</div><div>        }</div><div>        map.put(nums[i], i);</div><div>    }</div><div>    throw new IllegalArgumentException("No two sum solution");</div><div>}</div></div><div><b>Complexity Analysis:</b></div><div><br /></div><ul><li><div style="margin-bottom:16px;">Time complexity : O(n). We traverse the list containing n elements only once. Each look up in the table costs only O(1)time.</div></li><li><div style="margin-bottom:16px;">Space complexity : O(n). The extra space required depends on the number of items stored in the hash table, which stores at most n elements.</div></li></ul><div style="text-align:start;margin-bottom:16px;"><u><span style="--en-markholder:true;"><br /></span></u></div><ol start="3"><li><div style="text-align:start;"><span style="color:rgb(24, 168, 65);">When Given array is sorted, then use two pointer approach </span></div></li></ol><div style="--en-codeblock:true;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>    public int[] twoSum(int[] nums, int target) {</div><div>            int low = 0 , high = nums.length-1;</div><div>            while(low &lt; high){</div><div>            if(nums[low]+ nums[high] == target){</div><div>                return new int[]{low+1, high+1};   </div><div>             }else if(nums[low]+ nums[high] &gt; target)</div><div>                high--;</div><div>            else{</div><div>                low++;</div><div>              }</div><div>            }</div><div>                return new int[2];</div><div>       }</div></div><div style="text-align:start;"><b>Complexity analysis</b></div><div><br /></div><ul><li><div style="margin-bottom:16px;">Time complexity :<i>O</i>(<i>n</i>). Each of the n<i>n</i> elements is visited at most once, thus the time complexity is O(n).</div></li><li><div style="margin-bottom:16px;">Space complexity : O(1). We only use two indexes, the space complexity is O(1).</div></li></ul><div><br /></div></en-note>      ]]>
    </content>
  </note>
</en-export>
