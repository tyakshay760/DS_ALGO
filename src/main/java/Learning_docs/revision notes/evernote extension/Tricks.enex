<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export4.dtd">
<en-export export-date="20220122T102940Z" application="Evernote" version="10.24.3">
  <note>
    <title>Tricks</title>
    <created>20210705T031722Z</created>
    <updated>20210710T023146Z</updated>
    <note-attributes>
      <author>Akshay Yadav</author>
    </note-attributes>
    <content>
      <![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd"><en-note><ul><li><h3><span style="color:rgb(24, 168, 65);">Check repeated character in given string :</span></h3></li></ul><div><span style="color:rgb(24, 168, 65);"><span style="--en-markholder:true;"><br /></span></span></div><div style="--en-codeblock:true;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>&lt;-- check if String contains repeated character</div><div>private boolean checkRepetition(String s, int start, int end) { </div><div>        int[] chars = new int[128]; </div><div>        for (int i = start; i &lt;= end; i++) { </div><div>            char c = s.charAt(i); </div><div>            chars[c]++; </div><div>            if (chars[c] &gt; 1) { </div><div>                return false; </div><div>            } </div><div>        } </div><div>        return true; </div><div>    }</div></div><div>Time Complexity : O(n)</div><div>Space Complexity : O(n)</div><hr /><ul><li><div>  <span style="color:rgb(24, 168, 65);">Given a map having item with frequency, find the k element in top frequency order.</span></div></li></ul><div><span style="color:rgb(24, 168, 65);"><span style="--en-markholder:true;"><br /></span></span></div><div style="--en-codeblock:true;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><br /></div></div><div><br /></div><hr /><ul><li><div><span style="color:rgb(24, 168, 65);">    Time complexity of Hash-map get(key) and containsKey(key) method.</span></div></li></ul><ol><li><div><span style="color:rgb(51, 51, 51);">  Ideal Case: O(1)  - hash based search</span></div></li><li><div><span style="color:rgb(51, 51, 51);">  In case of collision: </span></div></li></ol><div><span style="color:rgb(51, 51, 51);">                      Data is stored in TreeNodes form (Red-Black) tree. and search in Tree is O(logN)</span></div><hr /><div><span style="color:rgb(51, 51, 51);"><span style="--en-markholder:true;"><br /></span></span></div><ul><li><div><span style="color:rgb(51, 51, 51);">   If we want to process anything in reverse order then </span><span style="color:rgb(24, 168, 65);">think of stack data structure. </span></div></li></ul><div><span style="color:rgb(24, 168, 65);">                Add elements to the stack first and then pop when ever it is required.</span></div><div><span style="color:rgb(24, 168, 65);"><span style="--en-markholder:true;"><br /></span></span></div><div><span style="color:rgb(24, 168, 65);"><span style="--en-markholder:true;"><br /></span></span></div><div><span style="color:rgb(51, 51, 51);"><span style="--en-markholder:true;"><br /></span></span></div><div><span style="color:rgb(24, 168, 65);">  </span><span style="color:rgb(51, 51, 51);"> </span></div><div><br /></div></en-note>      ]]>
    </content>
  </note>
</en-export>
