<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export4.dtd">
<en-export export-date="20220122T103031Z" application="Evernote" version="10.24.3">
  <note>
    <title>Find Median of Continuous Incoming Integer</title>
    <created>20210807T110328Z</created>
    <updated>20210807T142841Z</updated>
    <note-attributes>
      <author>Akshay Yadav</author>
    </note-attributes>
    <content>
      <![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd"><en-note><div>Problem: <a href="https://leetcode.com/problems/find-median-from-data-stream/" rev="en_rl_none">https://leetcode.com/problems/find-median-from-data-stream/</a></div><div><br /></div><div>Median : In any sorted array, median is:</div><div>                If array size is odd, then middle element will be median</div><div>                If array size is even, then there will be 2 median,  number at n/2 and number at n/2-1;</div><div>example : </div><div>arr<en-todo checked="false" />=  {1,2,3,4,5}   ans : 3 (middle no) : odd size array</div><div>arr<en-todo checked="false" />= {1,2,3,4,5,6}, ans = 3 and 4  --&gt; or (3+4)/2 = 3.5 more precise answer</div><div><br /></div><div><b>Broute force : </b></div><div>use list -&gt;  add every new element to list -&gt; sort the list every time you want to find the median -&gt; find the median as per above definition i.e find middle in case of odd elements in array or find avg of two middle no.</div><div><br /></div><div><b>Optimisation :  </b></div><div>As we need middle element(s) of sorted integer array. </div><div>Now think of Priority Queue. </div><div>PriorityQueue -&gt; Min PQ stores minimum element  at top and max PR stores max element at top. </div><div>if I store lower half in max PR -&gt; then top of  maxPQ will give me one middle element.</div><div>if I stores upper half in minPR -&gt; then top of minPQ will give another middle element. </div><div>Note : above cases will arises if number of element in given list is even because we will have 2 middle element now.</div><div><br /></div><div>if no of element is odd, then Top of PQ with more number of element will give answer. </div><div><br /></div><div style="--en-codeblock:true;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>class MedianFinder {</div><div><br /></div><div>    Queue&lt;Integer&gt; min;</div><div>    Queue&lt;Integer&gt; max;</div><div>    public MedianFinder() {</div><div>        min = new PriorityQueue&lt;&gt;();</div><div>        max = new PriorityQueue&lt;&gt;(Comparator.reverseOrder());</div><div>    }</div><div>    </div><div>    public void addNum(int num) {</div><div>        if(max.isEmpty() &amp;&amp;  min.isEmpty()){</div><div>          max.offer(num);</div><div>            return;</div><div>        }</div><div>            </div><div>        if(max.peek() &gt;= num){</div><div>            max.offer(num);</div><div>        }else{</div><div>            min.offer(num);</div><div>        }</div><div>        </div><div>        if(max.size() &gt; min.size()){</div><div>            int top = max.poll();</div><div>            min.offer(top);</div><div>        }else if(min.size() &gt; max.size()){</div><div>            int top = min.poll();</div><div>            max.offer(top);</div><div>        }</div><div>    }</div><div>    </div><div>    public double findMedian() {</div><div>        if(max.size() &gt; min.size()){</div><div>            return max.peek();</div><div>        }else if(min.size() &gt; max.size()){</div><div>            return min.peek();</div><div>        }else{</div><div>           int n1 = max.peek();</div><div>           int n2 = min.peek();</div><div>            return (n1+n2)/2.0;</div><div>        }    </div><div>    }</div><div>}</div><div><br /></div></div><div><br /></div></en-note>      ]]>
    </content>
  </note>
  <note>
    <title>Top K frequent element from array</title>
    <created>20210807T142330Z</created>
    <updated>20210808T095254Z</updated>
    <note-attributes>
      <author>Akshay Yadav</author>
    </note-attributes>
    <content>
      <![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd"><en-note><div>Question: <a href="https://leetcode.com/problems/top-k-frequent-elements/">https://leetcode.com/problems/top-k-frequent-elements/</a></div><div>ps : <span style="color:rgb(38, 50, 56);">Given an integer array </span><span style="color:rgb(84, 110, 122);">nums</span> and an integer <span style="color:rgb(84, 110, 122);">k</span>, return <i>the</i> <span style="color:rgb(84, 110, 122);">k</span> <i>most frequent elements</i>. You may return the answer in <b>any order</b>.</div><div style="text-align:start;"><b><span style="color:rgb(38, 50, 56);">Example 1:</span></b></div><div><br /></div><div style="--en-codeblock:true;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>Input: nums = [1,1,1,2,2,3], k = 2</div><div>Output: [1,2]</div><div><br /></div></div><div style="text-align:start;"><b><span style="color:rgb(38, 50, 56);">Example 2:</span></b></div><div><br /></div><div style="--en-codeblock:true;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>Input: nums = [1], k = 1</div><div>Output: [1]</div></div><div><br /></div><div><br /></div><div style="--en-codeblock:true;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>Max Heap Approach : NlogN time complexity</div><div>private class Node implements Comparable&lt;Node&gt; {</div><div>		int val;</div><div>		int freq;</div><div>		public Node(int val, int freq) {</div><div>			this.val = val;</div><div>			this.freq = freq;</div><div>		}</div><div>		public int compareTo(Node n) {</div><div>			return n.freq - this.freq;</div><div>		}</div><div>	}</div><div><br /></div><div>	public int[] topKFrequent(int[] nums, int k) {</div><div>		// Map each element in nums to its frequency</div><div>		Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</div><div>		for (int x : nums) map.put(x, map.getOrDefault(x, 0) + 1);</div><div><br /></div><div>		// Add keys and values in map to a priority queue</div><div>		// As per the compareTo() method of the Node class, </div><div>		// values with higher frequencies are at the top of the PQ </div><div>		Queue&lt;Node&gt; pq = new PriorityQueue&lt;&gt;();</div><div>		for (int key : map.keySet()) {</div><div>			pq.add(new Node(key, map.get(key)));</div><div>		}</div><div><br /></div><div>		// Now remove the top K elements from the PQ </div><div>		// and add them to the returned array. </div><div>		// By the Comparator, the top K elements will be the top K most frequent.</div><div>		int[] ans = new int[k];</div><div>		int counter = 0;</div><div>		while (counter &lt; k) {</div><div>			ans[counter] = pq.poll().val;</div><div>			counter += 1;</div><div>		}</div><div>    </div><div>		return ans;</div><div>	}</div><div><br /></div><div>Min heap approach </div><div><br /></div><div>class Solution {</div><div>    </div><div>    public int[] topKFrequent(int[] nums, int k) {</div><div>        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();</div><div>        for(int i=0; i &lt; nums.length ; i++){</div><div>            map.put(nums[i], map.getOrDefault(nums[i],0)+1);</div><div>        }</div><div>        </div><div>        // Queue will store Integer with minimum number of occurance at top.</div><div>            basically it is min head of map key object </div><div>        Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;( (num1,num2) -&gt; map.get(num1) - map.get(num2));</div><div>        </div><div>        for(int key : map.keySet()){</div><div>            queue.add(key);</div><div>            if(queue.size() &gt; k){</div><div>                queue.poll(); // as it is min head, all the key with less number of occuances will be                                                removed from heap/queue</div><div>            }</div><div>        }</div><div>         </div><div>        System.out.println(queue);</div><div>     int[] res = new int[k];</div><div>     for(int i=0; i &lt; k; i++){</div><div>         res[i] = queue.poll();</div><div>     }</div><div>        return res;</div><div>    }</div><div>}</div></div><div><br /></div></en-note>      ]]>
    </content>
  </note>
  <note>
    <title>Untitled Note</title>
    <created>20210807T142321Z</created>
    <updated>20210807T142321Z</updated>
    <note-attributes>
      <author>Akshay Yadav</author>
    </note-attributes>
    <content>
      <![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd"><en-note><div><br /></div></en-note>      ]]>
    </content>
  </note>
</en-export>
