<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export4.dtd">
<en-export export-date="20220122T103124Z" application="Evernote" version="10.24.3">
  <note>
    <title>All path to reach top of steps while taking either 1 or 2 steps at once</title>
    <created>20210723T101114Z</created>
    <updated>20210723T112903Z</updated>
    <note-attributes>
      <author>Akshay Yadav</author>
    </note-attributes>
    <content>
      <![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd"><en-note><div><a href="https://leetcode.com/problems/climbing-stairs">https://leetcode.com/problems/climbing-stairs</a></div><div><br /></div><ol><li><div>Recursion with memorization</div></li></ol><div style="--en-codeblock:true;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>class Solution {</div><div>    public int climbStairs(int n) {</div><div>        int[] memo = new int[n+1];</div><div>        return climb_stairs(0,n,memo);</div><div>    }</div><div>    </div><div>    public int climb_stairs(int currStep , int n, int[] memo){</div><div>        if(currStep &gt; n){</div><div>            return 0;</div><div>        }</div><div>        if(memo[currStep] != 0){</div><div>            return memo[currStep];</div><div>        }</div><div>        if(currStep==n){</div><div>            return 1;</div><div>        }</div><div>        memo[currStep] = climb_stairs(currStep + 1,n, memo) + climb_stairs(currStep + 2, n, memo);</div><div>        return memo[currStep];</div><div>    }</div><div>}</div><div><br /></div><div>Time Complexity : O(n)</div><div>Space complexity: O(n)</div></div><div><br /></div><ol start="2"><li><div>DP </div></li></ol><div style="--en-codeblock:true;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>class Solution {</div><div>    public int climbStairs(int n) {</div><div>        if(n == 1){</div><div>            return 1; </div><div>        }</div><div>        int[] dp = new int[n+1];</div><div>        dp[1] = 1;</div><div>        dp[2] = 2;</div><div>        </div><div>        for(int i=3; i &lt;= n ; i++){</div><div>            dp[i] = dp[i-1] + dp[i-2];</div><div>        }</div><div>       return dp[n];</div><div>    }</div><div>}</div><div><br /></div><div>Time Complexity : O(n)</div><div>Space complexity: O(n)</div></div><div><br /></div><ol start="3"><li><div>Fabonicee  approach:</div></li></ol><div>            If we are on ground, we can climb either one or 2 steps at time, if we step up 1 and 2 both, then we reach to 3. </div><div style="--en-codeblock:true;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>public class Solution {</div><div>    public int climbStairs(int n) {</div><div>        if (n == 1) {</div><div>            return 1;</div><div>        }</div><div>        int first = 1;</div><div>        int second = 2;</div><div>        for (int i = 3; i &lt;= n; i++) {</div><div>            int third = first + second;</div><div>            first = second;</div><div>            second = third;</div><div>        }</div><div>        return second;</div><div>    }</div><div>}</div></div><div><br /></div><div><br /></div></en-note>      ]]>
    </content>
  </note>
  <note>
    <title>Next Greater permutation</title>
    <created>20210716T094528Z</created>
    <updated>20210716T095443Z</updated>
    <note-attributes>
      <author>Akshay Yadav</author>
    </note-attributes>
    <content>
      <![CDATA[<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd"><en-note><div>Problem : Given a positive integer n, By using same digit find next grater permutation of the n. </div><div>i.e next number with same digit which is smallest among all the grater number of n. </div><div>exam: </div><div style="--en-codeblock:true;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>Input:  n = "218765"</div><div>Output: "251678"</div><div><br /></div><div>Input:  n = "1234"</div><div>Output: "1243"</div><div><br /></div><div>Input: n = "4321"</div><div>Output: "Not Possible"</div><div><br /></div><div>Input: n = "534976"</div><div>Output: "536479"</div></div><div><br /></div><div>observation:</div><ol><li><div>If number is sorted in descending order then no grater number is possible, given number itself is greatest number with those digits.</div></li><li><div>If all digits is sorted in ascending order, then just swap last two digit of a number. </div></li><li><div>for other cases below algorithm is used.</div></li><ol><ol><li><div> Iterate over the number from LSB i.r right most side</div></li><li><div> find the number whose next left number is smaller then current number. say at index i .</div></li><li><div>now  find search in array starting from i+1 to array end and find the number which is grater then element at i-1 and grater then element at i. </div></li><li><div>swap element at i-1 and min element.</div></li><li><div>then sort the array from i to length of array</div></li><li><div>return the result.</div></li></ol></ol></ol><div style="--en-codeblock:true;box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>class Solution {</div><div>    public int nextGreaterElement(int n) {</div><div>        String no = n + "";</div><div>        char[] ch = no.toCharArray();</div><div>        int i;</div><div>        for(i = ch.length-1; i &gt; 0 ; i--){</div><div>            if(ch[i] &gt; ch[i-1]){</div><div>                break;</div><div>            }</div><div>        }</div><div>        if(i==0){</div><div>            return -1;</div><div>        }else{</div><div>          int smaller = ch[i-1], min = i;</div><div>          for(int j = i+1; j &lt; ch.length ; j++){</div><div>              if(smaller &lt; ch[j] &amp;&amp; ch[j] &lt; ch[min]){</div><div>                  min = j;</div><div>              }</div><div>          }</div><div>         swap(ch,i-1,min);</div><div>         Arrays.sort(ch,i,ch.length);</div><div>        }     </div><div>        try {</div><div>            return Integer.parseInt(new String(ch));</div><div>        } catch (Exception e) {</div><div>            return -1;</div><div>        }</div><div>    }</div><div>    </div><div>    void swap(char[] ch, int i, int j){</div><div>        char temp = ch[i];</div><div>        ch[i] = ch[j];</div><div>        ch[j]= temp;</div><div>    }</div><div>}</div></div><div><br /></div></en-note>      ]]>
    </content>
  </note>
</en-export>
